{
  "hash": "4add56d0880d018366bea856c3af5f27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hex maps for species occurrence data\"\ndescription: |\n  Hexagonal grid maps (i.e. hex maps) are one way to display information about the distribution of a species and the relative frequency that a species occurs in a given area. Here we will show how to make a hex map of magpie observations in Australia using `sf` and `ggplot2`.\nauthor: \n  - name: \"Matilda Stevenson\"\n  - name: \"Dax Kellie\"\n  - name: \"Martin Westgate\"\ndate: \"March 2021\"\ndate-modified: \"6 February 2023\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Maps\n  - Eukaryota\n  - Animalia\n  - Chordata\n  - Aves\n  - R\nimage: magpie-hex-map.png\nfreeze: true\n---\n\n\n\n<!-- remove metadata section -->\n\n::: {.cell}\n<style type=\"text/css\">\n#title-block-header.quarto-title-block.default .quarto-title-meta {\n    display: none;\n}\n</style>\n:::\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\nMatilda Stevenson  \n[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/index.html)  \n[Martin Westgate](https://labs.ala.org.au/about/Westgate_Martin/index.html)  \n\n#### Date\nMarch 2021\n\n:::\n\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/matilda.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/martin.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\n:::{.callout-note}\nArticle updated 6 February, 2023. Updates streamline code, and provide more examples of output after each step. More in-text detail has also been added about what is happening at each step.\n:::\n\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let's make a visualisation of [Australian Bird of the Year 2018 winner](https://www.abc.net.au/news/2017-12-11/bird-of-the-year-magpie-defeats-teambinchicken/9245242), Magpies, using records held in the ALA.\n\n\n# Getting species occurrences\nAs with any R project, a good first step is to load the required packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(hexbin)\n```\n:::\n\n\nWe will use the [{galah} package](http://galah.ala.org.au/) to download records.\n\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to `galah_config()`. If running this code yourself, you will need to add an email using the code below, substituting your email with `myemail@email.com`. This email address should be registered with the ALA, which you can do [here](https://auth.ala.org.au/userdetails/registration/createAccount)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\ngalah_config(email = \"myemail@email.com\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nNow we can download magpie occurrence records by using `atlas_occurrences()`. Note that we also set our data 'profile' to 'ALA'; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. \n(If you wish to see the data quality filters applied in the ALA profile, use `search_all(profiles, \"ALA\") |> show_values()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagpie_occ <- galah_call() %>%\n  galah_identify(\"Cracticus tibicen\") %>%\n  galah_apply_profile(ALA) %>%\n  atlas_occurrences()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRetrying in 1 seconds.\nRetrying in 2 seconds.\nRetrying in 4 seconds.\nRetrying in 8 seconds.\nRetrying in 16 seconds.\nRetrying in 32 seconds.\nRetrying in 60 seconds.\n```\n\n\n:::\n:::\n\n\nLet's have a look at the first few rows of the data we've just downloaded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagpie_occ %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  <chr>           <chr>          <chr>                    <dbl>            <dbl>\n1 0000032b-8690-… Gymnorhina ti… https://biodi…           -37.0             145.\n2 0000150d-489d-… Gymnorhina ti… https://biodi…           -37.9             145.\n3 00001736-1fd8-… Gymnorhina ti… https://biodi…           -34.8             151.\n4 00001e12-29cf-… Gymnorhina ti… https://biodi…           -39.6             144.\n5 00001f60-0371-… Gymnorhina ti… https://biodi…           -35.2             149.\n6 000035cd-c3a1-… Gymnorhina ti… https://biodi…           -37.6             144.\n# ℹ 3 more variables: eventDate <dttm>, occurrenceStatus <chr>,\n#   dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\n\nFor the purpose of this exercise, we're going to filter records not on the mainland or Tasmania.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_occ <- magpie_occ %>% filter(decimalLongitude < 155,\n                                      decimalLongitude > 110,\n                                      decimalLatitude > -45,\n                                      decimalLatitude < -10)\n```\n:::\n\n\n# Plotting binned data\n\nThe easiest way to create a hex map is using the `hexbin` package. However, because there are some areas that have *many* more observations than other areas, without standardising our data the result is not very useful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_hex(data = filtered_occ,\n           mapping = aes(x = decimalLongitude, \n                         y = decimalLatitude), \n           bins = 47, \n           colour = \"white\") +\n  coord_sf(ylim = c(-45, -10), \n           xlim = c(110, 155)) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nTo make a more informative hex map, in this case it might be useful to try to create our hexagons manually. We can do this by creating a grid of hexagons, filtering the grid to the outline of Australia, and adding our data of magpie counts to set the `fill` color of those hexagons. \n\nTo achieve this, we can first convert the map of Australia provided by `ozmaps` to the same coordinate system as ALA data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naus <- st_transform(ozmaps::ozmap_country, 4326)\n```\n:::\n\n\nNext we'll create a grid of hexagons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_all <- st_make_grid(aus, \n                         cellsize = 1, \n                         what = \"polygons\", \n                         square = FALSE,\n                         flat_topped = TRUE)\n\nggplot() +\n  geom_sf(data = grid_all)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nNow we'll extract all the hexagons in our full grid that intersect our map of Australia, and filter our grid to only include those hexagons by only keeping the hexagon rows that are returned after running `st_intersects()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract rows that are within AUS land\nkeep_hexes <- st_intersects(grid_all, aus) %>%\n  as.data.frame(.) %>%\n  pull(row.id)\n\n# filter full grid to only hexagon IDs in AUS\noz_grid <- grid_all[keep_hexes]\n\nggplot() + geom_sf(data = oz_grid)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nNow to figure out how many magpie observations are within each hexagon. To do this, first we'll convert our magpie observation points to an `sf` spatial object and make sure the point projection is the same as our map of Australia. Then we can use `st_intersects()` again to return a list, where each `data.frame` within the list shows which hexagon ID each point is within.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagpie_points_sf <- filtered_occ %>% \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n  crs = st_crs(4326))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nintersect <- st_intersects(magpie_points_sf, oz_grid)\n\nintersect[5:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 69\n\n[[2]]\n[1] 43\n\n[[3]]\n[1] 414\n\n[[4]]\n[1] 31\n\n[[5]]\n[1] 185\n\n[[6]]\n[1] 67\n```\n\n\n:::\n:::\n\n\nWith all points in their own separate `data.frame`, we can use the wicked-fast `table()` function from `base` R to count how many points match each hexagon ID, giving us our point counts! A little renaming and wrangling helps to get our counts in the right format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# condense counts into tibble\ncounts <- as_tibble(table(unlist(intersect)), \n          .name_repair = \"unique\") %>%\n  rename(\"hex_id\" = 1,\n         \"count\" = 2) %>%\n  mutate(hex_id = as.integer(hex_id)) %>%\n  replace_na(list(count = 0))\n```\n:::\n\n\nWe'll add our `count` column from `complete_counts` to our `oz_grid`, along with an `id` column containing the row number. This column will act as a reference column to join with `complete_counts`. Then we'll also make sure that `oz_grid` is an `sf` object for plotting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noz_grid <- oz_grid %>%\n  as_tibble() %>%\n  mutate(id = row_number()) %>%\n  full_join(counts,\n            by = join_by(id == hex_id)) %>%\n  st_as_sf()\n\noz_grid |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 144.8105 ymin: -44.13203 xmax: 148.5632 ymax: -41.63203\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 3\n                                                            geometry    id count\n                                                       <POLYGON [°]> <int> <int>\n1 ((146.5425 -43.63203, 146.8312 -44.13203, 147.4085 -44.13203, 147…     1   591\n2 ((145.6765 -43.13203, 145.9652 -43.63203, 146.5425 -43.63203, 146…     2     9\n3 ((147.4085 -43.13203, 147.6972 -43.63203, 148.2746 -43.63203, 148…     3  1602\n4 ((144.8105 -42.63203, 145.0991 -43.13203, 145.6765 -43.13203, 145…     4     6\n5 ((146.5425 -42.63203, 146.8312 -43.13203, 147.4085 -43.13203, 147…     5  9692\n6 ((145.6765 -42.13203, 145.9652 -42.63203, 146.5425 -42.63203, 146…     6    71\n```\n\n\n:::\n:::\n\n\nFinally, let's build our map! We'll use `scale_fill_gradientn()` to add a nice legend, and standardise our data using a log-transformation so that the colours on our map are scaled to be more informative.\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = oz_grid, aes(fill = count), size = .01) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), \n                       na.value = \"white\", \n                       trans = \"log10\",\n                       labels = scales::comma_format(),\n                       n.breaks = 6,\n                       guide = guide_colourbar(title = \"Observations\")) +\n  coord_sf(ylim = c(-45, -10), \n           xlim = c(110, 155)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=10in style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\nThat's it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\n\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using `galah_geolocate()`. That's a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. You can learn how to do this in [this ALA Labs article, if you are interested to learn how!](https://labs.ala.org.au/posts/2022-05-17_3d-map/)\n\n<details><summary style = \"color: #E06E53;\">Expand for session info</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n hexbin      * 1.28.3  2023-03-21 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}