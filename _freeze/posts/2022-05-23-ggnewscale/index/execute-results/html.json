{
  "hash": "b4bb43e8060bcd462655680cd955363b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Multiple colour scales in choropleth maps with {ggnewscale}\"\ndescription: |\n  Using multiple colour scales can be a great way to visually differentiate between geographic categories on a map. Here, we demonstrate this by creating a choropleth map to represent the density of plant records from the ALA across bioregions in Australia, and add multiple colour scales to differentiate marine and terrestrial records    \nauthor:\n  - name: \"Shandiya Balasubramaniam\"\ndate: \"2022-05-31\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Eukaryota\n  - Plantae\n  - Chlorophyta\n  - Maps\n  - R\nimage: choropleth_ggnewscale.png\nfreeze: true\n---\n\n\n\n\n<!-- remove metadata section -->\n\n::: {.cell}\n<style type=\"text/css\">\n#title-block-header.quarto-title-block.default .quarto-title-meta {\n    display: none;\n}\n</style>\n:::\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\n[Shandiya Balasubramaniam](https://labs.ala.org.au/about/Balasubramaniam_Shandiya/index.html)  \n\n#### Date\n23 May 2022\n\n:::\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.png){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nChoropleth maps visually summarise how variables (like species richness or population density, for example) vary across geographic areas. These maps require two inputs:  \n\n* a geospatial object with information on regional boundaries\n* a numerical variable that can be mapped to each geographic unit using colour \n\nHere, I walk through the process of mapping the density of plant records from the ALA to geographic bioregions across Australia, using two colour scales to differentiate between marine and terrestrial records. \n\n# Get geospatial and count data \n\nLet's start by loading the packages we'll need. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\nlibrary(here)\nlibrary(sf)\nlibrary(rmapshaper)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(ggnewscale)\n```\n:::\n\n\nNext, we'll need some regional boundaries. I think the [IBRA7](https://data.gov.au/dataset/ds-dga-d44dd392-ebea-4f1a-b30e-4a2da154aae4/details?q=ibra) and [IMCRA4](https://data.gov.au/dataset/ds-dga-3245ad6c-cc00-4404-ba1f-476c07b5f762/details?q=imcra) bioregions will work nicely for what we're planning. These boundaries classify Australia's landscapes and waters into geographically distinct bioregions based on variables like climate, geomorphology, and species information. \n\nAfter downloading the data, we can read it in using the [`sf` package](https://r-spatial.github.io/sf/) and check that it looks correct. Here, I've also elected to use `ms_simplify()` from the [`rmapshaper` package](https://github.com/ateucher/rmapshaper) to simplify the geospatial features and speed up computation.    \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in IMCRA shapefile\nimcra_shp <- st_read(here(\"posts\", \n                          \"data\",\n                          \"imcra_mesoscale_bioregions\",\n                          \"imcra4_meso.shp\"), \n                     quiet = TRUE) |> \n  ms_simplify(keep = 0.1)\n\n# read in IBRA shapefile\nibra_shp <- st_read(here(\"posts\",\n                         \"data\",\n                         \"IBRA7_regions\",\n                         \"ibra7_regions.shp\"),\n                    quiet = TRUE) |> \n  ms_simplify(keep = 0.1)\n```\n:::\n\n\nAnd finally, let's get the number of plant records in the ALA using the [`galah` package](https://atlasoflivingaustralia.github.io/galah/index.html), grouped by IBRA or IMCRA region. To do this, we need to know what the ALA calls the IBRA and IMCRA layers. \n\nUsing the `search_fields()` function, we can determine that the IBRA layer we're after is called **cl1048** and the IMCRA layer, **cl966**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch_fields(\"IBRA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  id     description       type  \n  <chr>  <chr>             <chr> \n1 cl20   IBRA 6 Regions    fields\n2 cl1048 IBRA 7 Regions    fields\n3 cl1049 IBRA 7 Subregions fields\n```\n\n\n:::\n\n```{.r .cell-code}\nsearch_fields(\"IMCRA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  id    description                 type  \n  <chr> <chr>                       <chr> \n1 cl21  IMCRA Regions               fields\n2 cl966 IMCRA Meso-scale Bioregions fields\n```\n\n\n:::\n:::\n\n\nTo get counts of records from the ALA, we can pass a query with `galah_call()` and build our query using pipes. \n\nWe will specify that we only want plant records matching *Plantae* or *Chlorophyta* using `galah_identify()`, apply the default set of ALA data quality filters to remove poor quality records using `galah_filter()`, group records by region using `galah_group_by()`, and finally return the counts of records that match all our criteria with `atlas_counts()`.    \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# counts in IBRA regions\nibra_counts <- galah_call() |>\n  galah_identify(\"plantae\", \"chlorophyta\") |>\n  galah_filter(profile = \"ALA\") |> \n  galah_group_by(\"cl1048\") |>      # IBRA regions\n  atlas_counts()\n\nhead(ibra_counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  cl1048                      count\n  <chr>                       <int>\n1 Sydney Basin              2809259\n2 South Eastern Highlands   1833611\n3 South Eastern Queensland  1104671\n4 NSW North Coast            925380\n5 South East Corner          909572\n6 Murray Darling Depression  904340\n```\n\n\n:::\n\n```{.r .cell-code}\n# counts in IMCRA regions\nimcra_counts <- galah_call() |>\n  galah_identify(\"plantae\", \"chlorophyta\") |>\n  galah_filter(profile = \"ALA\") |> \n  galah_group_by(\"cl966\") |>      # IMCRA bioregions\n  atlas_counts()\n\nhead(imcra_counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  cl966                 count\n  <chr>                 <int>\n1 Shoalwater Coast     434913\n2 Lucinda-Mackay Coast 260228\n3 Torres Strait        242812\n4 West Cape York       215772\n5 Wet Tropic Coast     143362\n6 Pellew                91955\n```\n\n\n:::\n:::\n\n\n# Join geospatial and count data\n\nWe now have the two things we need to make a choropleth map: \n\n* IBRA/IMCRA boundaries \n* counts of plant records in each region\n\nTo create a plot, we need to combine the geospatial and numeric data. But first, let's check if the data needs to be tidied.  \n\nAs we're going to be joining the spatial and count data, we need to be sure that the names of the IBRA/IMCRA regions match in both datasets. To double check that all of our region names match, we'll use `setdiff()`. There are no name mismatches when `character(0)` is returned, but if any region names are returned that means there is a problem somewhere that we need to fix before joining our dataframes. \n\nWhen we run `setdiff()`, the IBRA names match perfectly, but there's a mismatch in two IMCRA names. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check region names match\nsetdiff(ibra_counts$cl1048, ibra_shp$REG_NAME_7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Pilbarra (nearshore)\" \"Pilbarra (offshore)\" \n```\n\n\n:::\n:::\n\n\nReversing the order of IMCRA data frames in `setdiff()` reveals that that *Pilbara* is misspelled in the `imcra_counts` dataset. We can easily change this and confirm both sets of names match before continuing. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check the reverse for IMCRA names\nsetdiff(imcra_shp$MESO_NAME, imcra_counts$cl966)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Pilbara (offshore)\"  \"Pilbara (nearshore)\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# replace \"Pilbarra\" with \"Pilbara\" \nimcra_counts <- imcra_counts |> \n  mutate(cl966 = str_replace(string = cl966, \n                             pattern = \"Pilbarra\", \n                             replacement = \"Pilbara\"))\n\n# check names match\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\nNow let's check how our data are distributed so we can decide whether we should scale them with a transformation before plotting. Data skewed too far to the right will not show differences very clearly when they are mapped. \n\nChecking the distribution of counts in each dataset shows a substantial skew to the right.  \n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nhist(imcra_counts$count)\nhist(ibra_counts$count)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hist-1.png){width=672 style=margin-left:auto;margin-right:auto;}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/hist-2.png){width=672 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\nApplying a log-transformation to the count data makes the distribution more symmetrical. \n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nhist(log(imcra_counts$count))\nhist(log(ibra_counts$count))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/log-hist-1.png){width=672 style=margin-left:auto;margin-right:auto;}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/log-hist-2.png){width=672 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n \nNext, we join the geospatial and numeric data. Along the way, we rename some columns, remove unnecessary columns, calculate counts as a proportion of the area of each region (so we're plotting density of records, not counts of records), and convert the resulting dataframe into a simple features object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nimcra_join <- imcra_counts |> \n  full_join(y = imcra_shp, by = c(\"cl966\" = \"MESO_NAME\")) |> \n  rename(\"imcra\" = \"cl966\") |> \n  select(imcra, count, AREA_KM2, geometry) |> \n  mutate(density_log10 = log10(count / AREA_KM2)) |> \n  select(imcra, density_log10, geometry) |> \n  st_as_sf()\n\nibra_join <- ibra_counts |> \n  full_join(y = ibra_shp, by = c(\"cl1048\" = \"REG_NAME_7\")) |> \n  rename(\"ibra\" = \"cl1048\") |> \n  select(ibra, count, SQ_KM, geometry) |> \n  mutate(density_log10 = log10(count / SQ_KM)) |> \n  select(ibra, density_log10, geometry) |> \n  st_as_sf()\n```\n:::\n\n\n\n# Make a map   \n\nFinally, we'll use the [`ggnewscale` package](https://eliocamp.github.io/ggnewscale/) to apply different colour palettes to the marine and terrestrial data in a choropleth map. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = imcra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IMCRA\",\n                       type = \"seq\",\n                       palette = \"BuPu\",\n                       direction = 1,\n                       labels = c(\"0.001\", \"0.01\", \"0.1\", \"1\", \"10\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\")) +\n  # adds new colour scale\n  ggnewscale::new_scale_fill() +\n  geom_sf(data = ibra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IBRA\",\n                       type = \"seq\",\n                       palette = \"YlOrBr\",\n                       direction = 1,\n                       labels = c(\"0.1\", \"1\", \"10\", \"100\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\")) +\n  # adds a title for both legends\n  annotate(\"text\", \n           x = 133, \n           y = -45.5, \n           label = \"No. of records per square km\",\n           size = 6) +\n  coord_sf(xlim = c(110, 155), ylim = c(-45, -10)) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(12, 'mm'))\n```\n:::\n\n::: {.cell .fig-column-screen layout-align=\"center\"}\n::: {.cell-output-display}\n![](choropleth_ggnewscale.png){fig-align='center' width=12in style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\nSuccess!  \n\nOne thing to note is that we didn't necessarily have to use `ggnewscale` here; we could just as easily have combined all the data and plotted them on the same map without keeping the IBRA and IMCRA datasets separate. But, i) it's nice to be able to differentiate marine and terrestrial regions at a glance, and ii) using two legends also makes it clear that there's a stark difference in the number of plant records for marine and terrestrial regions.  \n\n\n<details><summary style = \"color: #E06E53;\">Expand for session info</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggnewscale  * 0.4.9   2023-05-25 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n rmapshaper  * 0.5.0   2023-04-11 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}