{
  "hash": "d07bf6471fa80c857e74c9292ada4921",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Combining multiple species distributions on one map with hexagons and points\"\ndescription: |\n  Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a way to show several species distributions in an area at once using a novel twist on the commonly used hexbin map.\nauthor:\n  - name: \"Callum Waite\"\n  - name: \"Shandiya Balasubramaniam\"\ndate: \"2024-01-25\"\ntitle-block-banner: \"#B8573E\"\ninclude-after-body: _footer.html\ntoc: true\ntoc-location: left\ntoc-depth: 3\nfilters: \n  - lightbox\nlightbox: true\ncategories:\n  - Eukaryota\n  - Animalia\n  - Chordata\n  - Aves\n  - Maps\n  - R\nimage: map_hexbin-points.png\ndraft: false\nfreeze: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n<!-- remove metadata section -->\n\n\n```{=html}\n<style>\n  #title-block-header.quarto-title-block.default .quarto-title-meta {\n      display: none;\n  }\n</style>\n```\n\n<!-- Author card -->\n\n::: author-card\n::: author-card-text\n#### Author\n\n[Callum Waite](https://labs.ala.org.au/people/Waite_Callum/index.html)\\\n[Shandiya Balasubramaniam](https://labs.ala.org.au/people/Balasubramaniam_Shandiya/index.html)\n\n#### Date\n\n25 January 2024\n:::\n\n::: author-card-image\n\n::: {.cell lightbox='false'}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/callum.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n::: author-card-image\n\n::: {.cell lightbox='false'}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.png){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nVisualisations of species distributions can be very simple yet effective ways of conveying biological and ecological information, such as range, habitat, and relative population size. \n\nRepresenting more than one species distribution in a single figure can be difficult, though, especially where there are areas of overlap. Points and colour-filled polygons will obscure each other even with a degree of transparency, while densities and shaded regions can only show one species at a time. \n\nHere, we demonstrate a method to visualise distributions of multiple species with overlapping ranges on the same map, with only a small loss in resolution. The technique is a novel twist on the commonly used [hexbin map](https://r-graph-gallery.com/hexbin-map.html): instead of using a colour fill to represent presence/absence or counts within each hexagon, we use multiple coloured points within each hexagon to represent presence/absence of species, allowing users to get a broad overview of how multiple species are distributed across an area.\n\nThis method requires a number of steps to build up the elements of the final figure:\n\n  *  Getting occurrence records for species of interest\n  *  Creating a hex grid over the area of occupancy for those species\n  *  Assigning locations and colour to each species within each hex\n\nThe final figure will comprise a combination of the basemap, hex grid, and species points once these elements are created. \n\nLet's begin by loading the R packages we'll be using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\nlibrary(ggtext)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(showtext)\nlibrary(stringr)\nlibrary(tidyverse)\n```\n:::\n\n\nWe'll use the [{galah} package](https://galah.ala.org.au) to download occurrence records from the [Atlas of Living Australia (ALA)](https://www.ala.org.au). To do this, you'll need to [register your email address with the ALA](https://auth.ala.org.au/userdetails/registration/createAccount), then pass it to {galah} using `galah_config()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalah_config(email = \"your-email@email.com\")\n```\n:::\n\n\n## Download data\n\nSince our goal here is to map distributions of multiple species, we've chosen honeyeaters from the genus *Melithreptus*: this is a distinctive group of 7 small- to medium-sized, short-billed and square-tailed honeyeaters with overlapping distributions across Australia.\n\n::: {layout-ncol=\"3\" style=\"margin-left: auto; margin-right: auto;\"}\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/a/2/5/323bd0bc-545f-48fa-85aa-eb77dcd052a3/original\" class = \"rounded\"/></img>\n\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/b/7/c/a/d96d11b4-4150-48c2-990a-20b70064ac7b/original\" class=\"rounded\"/></img>\n\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/6/1/5/2/03f17fd7-a256-44c8-a377-011784ef2516/original\" class=\"rounded\"/></img>\n:::\n\n::: figure-caption\nLeft: [*Melithreptus gularis* - Black-chinned Honeyeater (Graham Winterflood CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/53209bab-d2c1-4aab-ace7-e2de155389ae), Middle: [*Melithreptus chloropsis* - Gilbert's Honeyeater (Wacrakey CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/a0792deb-18a9-4e59-9419-add4d7b5d0c9), Right: [*Melithreptus validirostris* - Strong-billed Honeyeater (Bird Explorers CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/26edb457-4c80-4073-a6a8-176e68cf431e)\n:::\n\nWe can get taxonomic information about this group using `atlas_species()`...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelithreptus <- galah_call() |>\n  galah_identify(\"Melithreptus\") |>\n  atlas_species()\n\nmelithreptus\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 10\n  kingdom  phylum   class order         family genus species author species_guid\n  <chr>    <chr>    <chr> <chr>         <chr>  <chr> <chr>   <chr>  <chr>       \n1 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Viei… https://bio…\n2 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Vigo… https://bio…\n3 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… Gould… https://bio…\n4 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Goul… https://bio…\n5 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Less… https://bio…\n6 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… (Goul… https://bio…\n7 Animalia Chordata Aves  Passeriformes Melip… Meli… Melith… Gould… https://bio…\n# ℹ 1 more variable: vernacular_name <chr>\n```\n\n\n:::\n:::\n\n\n... and then use this information to download occurrence records for the 7 species. We'll apply a general set of ALA data quality filters to remove low quality records with `galah_apply_profile()`, and pass in the list of species we're interested in with `galah_identify()`. We'll also filter records to 2022[^1], choosing only those with spatial coordinates and that fall within one of the [IBRA bioregions](https://www.dcceew.gov.au/environment/land/nrs/science/ibra) (as a proxy for Australian records only).\n\n[^1]: There are over half a million records from this genus in the ALA, so restricting our download to records from 2022 significantly speeds things up!\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_occ <- galah_call() |>\n  galah_apply_profile(ALA) |>\n  galah_identify(melithreptus$species) |>\n  galah_filter(year == 2022,\n               !is.na(cl1048),  # IBRA bioregions\n               !is.na(decimalLatitude),\n               !is.na(decimalLongitude)) |>\n  galah_select(decimalLatitude,\n               decimalLongitude,\n               species, \n               scientificName) |> \n  atlas_occurrences()\n\nhead(species_occ)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  decimalLatitude decimalLongitude species                    scientificName    \n            <dbl>            <dbl> <chr>                      <chr>             \n1           -43.6             147. Melithreptus validirostris Melithreptus (Eid…\n2           -43.6             147. Melithreptus validirostris Melithreptus (Eid…\n3           -43.5             146. Melithreptus validirostris Melithreptus (Eid…\n4           -43.5             147. Melithreptus affinis       Melithreptus (Mel…\n5           -43.5             147. Melithreptus affinis       Melithreptus (Mel…\n6           -43.5             147. Melithreptus validirostris Melithreptus (Eid…\n```\n\n\n:::\n:::\n\n\nSince we're going to be performing a few spatial operations to assign species to hexagons, let's convert the `species_occ` dataframe into a simple features (`sf`) object, with latitude and longitude columns represented as points in a geometry column named `occ_geometry`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_occ_sf <- species_occ |>\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) |> \n  st_set_geometry(\"occ_geometry\")\n\nhead(species_occ_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 146.1362 ymin: -43.59761 xmax: 147.1435 ymax: -43.48602\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 3\n  species                    scientificName                    occ_geometry\n  <chr>                      <chr>                              <POINT [°]>\n1 Melithreptus validirostris Melithreptus (Eidopsarus… (146.8627 -43.59761)\n2 Melithreptus validirostris Melithreptus (Eidopsarus… (146.8627 -43.59761)\n3 Melithreptus validirostris Melithreptus (Eidopsarus… (146.1362 -43.50299)\n4 Melithreptus affinis       Melithreptus (Melithrept… (147.1435 -43.49038)\n5 Melithreptus affinis       Melithreptus (Melithrept… (146.9424 -43.48602)\n6 Melithreptus validirostris Melithreptus (Eidopsarus… (146.9424 -43.48602)\n```\n\n\n:::\n:::\n\n\n## Generate hex grid\n\nNext, we'll set up a grid of hexagons across Australia, which we'll use as bins for plotting summaries of species occurrence. \n\n`st_make_grid()` can make a grid that covers the bounding box of the supplied shapefile (here the `ozmap_country` shapefile), with  arguments for specifying the size, type, and orientation of polygons in a grid. We'll transform the projection to match the coordinate reference system we set for the species occurrence records above (`4326`), and assign a unique identifier to each hexagon in a column named `hex_id`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_grid <- st_make_grid(ozmap_country,\n                         cellsize = 2,\n                         what = \"polygons\",\n                         square = FALSE,\n                         flat_topped = TRUE) |> \n  st_as_sf() |> \n  st_set_geometry(\"hex_geometry\") |> \n  st_transform(4326) |> \n  rowid_to_column(var = \"hex_id\")\nhex_grid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 703 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 104.396 ymin: -45.63203 xmax: 170.7912 ymax: -7.632027\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   hex_id                   hex_geometry\n1       1 POLYGON ((106.128 -44.63203...\n2       2 POLYGON ((109.5921 -44.6320...\n3       3 POLYGON ((113.0562 -44.6320...\n4       4 POLYGON ((116.5203 -44.6320...\n5       5 POLYGON ((119.9844 -44.6320...\n6       6 POLYGON ((123.4485 -44.6320...\n7       7 POLYGON ((126.9126 -44.6320...\n8       8 POLYGON ((130.3767 -44.6320...\n9       9 POLYGON ((133.8408 -44.6320...\n10     10 POLYGON ((137.3049 -44.6320...\n```\n\n\n:::\n:::\n\n\n\nOur grid of hexagons looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_sf(data = ozmap_states, \n          colour = \"darkgrey\", \n          fill = NA, \n          linewidth = 0.3) +\n  geom_sf(data = hex_grid, \n          fill = NA, \n          col = \"deepskyblue4\", \n          linewidth = 0.2) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n### Remove empty hexes\n\nYou've probably noticed there are a lot of redundant hexagons in the grid we just created. Not every terrestrial hexagon will contain an occurrence record, and we can confidently assume hexagons in the ocean will not contain records of honeyeaters.\n\nWe'll remove these empty hexagons with a spatial join (which behaves similarly to `dplyr::left_join()` for spatial objects). This returns a dataframe that has all the information from our original occurrence download, where each row is a record of a species in a particular location, but each record's point location has now been matched to a hexagon from the grid we just created. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_with_species <- st_join(x = hex_grid, \n                            y = species_occ_sf,\n                            join = st_intersects,\n                            left = FALSE)\n\nhead(hex_with_species, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 145.9652 ymin: -44.63203 xmax: 148.2746 ymax: -42.63203\nGeodetic CRS:  WGS 84\n     hex_id                    species                          scientificName\n32       32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.1     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.2     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.3     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n32.4     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n32.5     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.6     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.7     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.8     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.9     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n                       hex_geometry\n32   POLYGON ((145.9652 -43.6320...\n32.1 POLYGON ((145.9652 -43.6320...\n32.2 POLYGON ((145.9652 -43.6320...\n32.3 POLYGON ((145.9652 -43.6320...\n32.4 POLYGON ((145.9652 -43.6320...\n32.5 POLYGON ((145.9652 -43.6320...\n32.6 POLYGON ((145.9652 -43.6320...\n32.7 POLYGON ((145.9652 -43.6320...\n32.8 POLYGON ((145.9652 -43.6320...\n32.9 POLYGON ((145.9652 -43.6320...\n```\n\n\n:::\n:::\n\n\nThis means any hexagons we initially created in the grid that don't intersect with occurrence records have been removed:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_sf(data = ozmap_states, \n          colour = \"darkgrey\", \n          fill = NA, \n          linewidth = 0.3) +\n  geom_sf(data = count(hex_with_species, hex_id, hex_geometry), \n          fill = NA, \n          col = \"deepskyblue4\", \n          linewidth = 0.4) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### Visualising multiple species in a hexagon\n\n\n::: {.cell}\n\n:::\n\n\nAs some hexagons will contain occurrence records for more than one species, we need a way to display these overlaps. We'll do this by setting up 7 positions in each hexagon, 1 for each species, and assign each species a position and colour so they can be visually differentiated. \n\nThe figure below summarises the process we'll follow: for each hexagon remaining in the grid, we'll generate a smaller hexagon, then get the coordinates of each vertex and centroid of the smaller hexagon. This gives us 7 positions to display up to 7 species in each hexagon.\n\n:::{layout-align=center}\n\n::: {.cell .column-page lightbox='{\"group\":\"hex\",\"description\":\"Steps to build a grid of points inside each hexagon\"}'}\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-17-1.png){width=960 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n:::\n\n### Set up 7 points\n\nLet's start by extracting the unique identifiers and spatial coordinates for every hexagon containing an occurrence record[^2]. Each `hex_id` refers to one of the remaining hexagons in our grid. This is step 1 from the figure above. \n\n[^2]: Using `distinct()` produces an identical result to `count()` here, but is far slower because checking for distinct values in the geometry column is computationally intensive. If your dataframe has fewer rows, you could also do this: `hex_with_species |> select(hex_id, hex_geometry) |> distinct()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_hex <- hex_with_species |> \n  count(hex_id, hex_geometry) |> \n  select(-`n`)\nunique_hex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 157 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 113.0562 ymin: -44.63203 xmax: 155.2028 ymax: -9.632027\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   hex_id                   hex_geometry\n1      32 POLYGON ((145.9652 -43.6320...\n2      50 POLYGON ((144.2331 -42.6320...\n3      51 POLYGON ((147.6972 -42.6320...\n4      70 POLYGON ((145.9652 -41.6320...\n5      88 POLYGON ((144.2331 -40.6320...\n6      89 POLYGON ((147.6972 -40.6320...\n7     107 POLYGON ((142.5011 -39.6320...\n8     108 POLYGON ((145.9652 -39.6320...\n9     125 POLYGON ((140.769 -38.63203...\n10    126 POLYGON ((144.2331 -38.6320...\n```\n\n\n:::\n:::\n\n\nNext, we'll work through steps 2 - 4. Let's create a smaller hexagon within each original hex using `st_buffer()`, extract the coordinates of its vertices using `st_coordinates()`, and assign an integer to each vertex ranging from 1 to 7[^3]. We've created an anonymous function to pipe these steps together, and used `pmap()` to apply this function iteratively to every hexagon in the grid. \n\n[^3]: Each hexagon is formed as a closed (rather than open) polygon, whereby the vertices are joined in the following order: 1-2-3-4-5-6-1. So although there are only 6 vertices, we get 7 sets of coordinates, with the first and seventh sets being duplicated to close the polygon.\n\n:::{.callout-note collapse='true'}\nWe use the `dist` argument in `st_buffer()` to define the size of the smaller hexagon, but this depends on the `cellsize` of the original larger hexagon (in the six-hexagon figure, `cellsize` = 2). Depending on the number of species you'd like to fit within each polygon and the shape of the polygon you've chosen, you may need to try out different values of `cellsize` and `dist` to find combinations that work best for your visualisation.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_coords <- unique_hex |> \n  mutate(vertices = pmap(\n    .l = list(x = hex_geometry),\n    .f = function(x) {\n      x |>\n        st_buffer(dist = -0.4) |>         # STEP 2: set size of smaller hex\n        st_coordinates() |>               # STEP 3: get vertex coordinates of smaller hex        \n        as_tibble() |>                    # convert matrix to tibble  \n        st_as_sf(coords = c(\"X\", \"Y\")) |> # convert tibble to simple features\n        select(-L1, -L2) |>               # remove unnecessary columns\n        mutate(vertex_position = 1:7)     # STEP 4: number vertices \n    })) |> \n  unnest(cols = vertices)\n\nhead(vertex_coords, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 2 fields\nActive geometry column: hex_geometry\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 144.2331 ymin: -44.63203 xmax: 148.2746 ymax: -41.63203\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 4\n   hex_id                 hex_geometry             geometry vertex_position\n    <int>                <POLYGON [°]>              <POINT>           <int>\n 1     32 ((145.9652 -43.63203, 146.5… (146.4271 -43.63203)               1\n 2     32 ((145.9652 -43.63203, 146.5… (146.7735 -43.03203)               2\n 3     32 ((145.9652 -43.63203, 146.5… (147.4663 -43.03203)               3\n 4     32 ((145.9652 -43.63203, 146.5… (147.8127 -43.63203)               4\n 5     32 ((145.9652 -43.63203, 146.5… (147.4663 -44.23203)               5\n 6     32 ((145.9652 -43.63203, 146.5… (146.7735 -44.23203)               6\n 7     32 ((145.9652 -43.63203, 146.5… (146.4271 -43.63203)               7\n 8     50 ((144.2331 -42.63203, 144.8…  (144.695 -42.63203)               1\n 9     50 ((144.2331 -42.63203, 144.8… (145.0414 -42.03203)               2\n10     50 ((144.2331 -42.63203, 144.8… (145.7342 -42.03203)               3\n```\n\n\n:::\n:::\n\n\nIn the resulting dataframe, the `hex_id` and `hex_geometry` columns contain the unique ID and geometry of the original large hexagons from the grid. Meanwhile, the remaining columns contain information for our newly created smaller hexagons: the `geometry` column contains the spatial coordinates of each hexagon's respective corner vertex, and `vertex_position` identifies each vertex point. \n\nWe'd like to show information of 7 species in our hexagon, but despite having 7 points in `vertex_position`, the 7th point contains the same information as the 1st point. This is so that, when drawn by lines, the hexagon is closed. However, because we are only interested drawing points, we can mutate the duplicated row of the 7th vertex to hold the coordinates of the centroid of each hexagon instead. This will gives us seven distinct positions (step 5 in our six-hexagon figure).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvertex_centroid_coords <- vertex_coords |> \n  mutate(geometry = ifelse(vertex_position == 7,      \n                           st_centroid(hex_geometry), \n                           geometry)) |> \n  st_drop_geometry() |>                               \n  st_as_sf(crs = 4326)\n\nhead(vertex_centroid_coords, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 144.695 ymin: -44.23203 xmax: 147.8127 ymax: -42.03203\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 3\n   hex_id             geometry vertex_position\n    <int>          <POINT [°]>           <int>\n 1     32 (146.4271 -43.63203)               1\n 2     32 (146.7735 -43.03203)               2\n 3     32 (147.4663 -43.03203)               3\n 4     32 (147.8127 -43.63203)               4\n 5     32 (147.4663 -44.23203)               5\n 6     32 (146.7735 -44.23203)               6\n 7     32 (147.1199 -43.63027)               7\n 8     50  (144.695 -42.63203)               1\n 9     50 (145.0414 -42.03203)               2\n10     50 (145.7342 -42.03203)               3\n```\n\n\n:::\n:::\n\n\n## Assign species to positions\n\nThe `melithreptus` dataframe (created earlier using `atlas_species()`) requires a small amount of tidying to be compatible with the rest of our data. The `species` column contains subgenera, which we can remove with regular expressions (regex)[^4]. We also need to ensure all species have a vernacular name, noting that *Melithreptus chloropsis* is currently lacking one in the ALA database. We can then assign a number (1-7) denoting each species' position in a hexagon[^5].\n\n[^4]: Regular expressions, or regex, are used to match specific patterns in strings. Here, we want to remove the inclusion of subgenera, parentheses, and any extra spaces in species names (e.g. `\"Melithreptus (Melithreptus) affinis\"` to `\"Melithreptus  affinis\"`), and we do this using `species = str_replace_all(species, \"\\\\(.*?\\\\)\\\\s*\", \"\")`. We're looking for a sequence that starts with an opening parenthesis (`\\\\(`), is followed by any characters (`.*?`), and ends with a closing parenthesis (`\\\\)`). Any spaces following the closing parenthesis (`\\\\s*`) are also matched. Such sequences are replaced with an empty string (`\"\"`), effectively removing them. \n\n[^5]: Here we assign the positions simply with `vertex_position = c(1:7)`, however you can reorder the dataframe or this position vector to have more control over which point in the hexagon each species is assigned. For instance, you might wish to do this to separate similar colours within the hexagon, or to assign the most widely distributed species to the centre point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_data <- melithreptus |>\n  select(species, vernacular_name) |>\n  mutate(species = str_replace_all(species, \"\\\\(.*?\\\\)\\\\s*\", \"\"),\n         vernacular_name = if_else(species == \"Melithreptus chloropsis\", \n                                   \"Gilbert's Honeyeater\",\n                                   vernacular_name),\n         vertex_position = c(1:7))\n\nspecies_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  species                    vernacular_name           vertex_position\n  <chr>                      <chr>                               <int>\n1 Melithreptus lunatus       White-naped Honeyeater                  1\n2 Melithreptus brevirostris  Brown-headed Honeyeater                 2\n3 Melithreptus albogularis   White-throated Honeyeater               3\n4 Melithreptus gularis       Black-chinned Honeyeater                4\n5 Melithreptus affinis       Black-headed Honeyeater                 5\n6 Melithreptus validirostris Strong-billed Honeyeater                6\n7 Melithreptus chloropsis    Gilbert's Honeyeater                    7\n```\n\n\n:::\n:::\n\n\nOur final step is to bring these three dataframes (`hex_with_species`, `species_data`, `vertex_centroid_coords`) together with `dplyr::left_join()`. \n\nWe begin by joining our distinct hexagon and species combinations (`hex_with_species`) with our species positions and common names (`species_data`) using the `species` column...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_points_a <- hex_with_species |>\n  st_drop_geometry() |>\n  select(hex_id, species) |>\n  distinct() |> \n  left_join(species_data,\n            by = join_by(species))\n\nhead(species_points_a, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   hex_id                    species          vernacular_name vertex_position\n1      32 Melithreptus validirostris Strong-billed Honeyeater               6\n2      32       Melithreptus affinis  Black-headed Honeyeater               5\n3      50 Melithreptus validirostris Strong-billed Honeyeater               6\n4      50       Melithreptus affinis  Black-headed Honeyeater               5\n5      51 Melithreptus validirostris Strong-billed Honeyeater               6\n6      51       Melithreptus affinis  Black-headed Honeyeater               5\n7      70       Melithreptus affinis  Black-headed Honeyeater               5\n8      70 Melithreptus validirostris Strong-billed Honeyeater               6\n9      88 Melithreptus validirostris Strong-billed Honeyeater               6\n10     88       Melithreptus affinis  Black-headed Honeyeater               5\n```\n\n\n:::\n:::\n\n\n...and follow this with another join to get the point coordinates of each species' point in each hexagon (`vertex_centroid_coords`), using the `vertex_position` and `hex_id` columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_points <- species_points_a |>\n  left_join(vertex_centroid_coords,\n            by = join_by(vertex_position, hex_id)) |> \n  st_as_sf(crs = 4326)\n\nhead(species_points, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 145.0414 ymin: -44.23203 xmax: 149.1983 ymax: -41.23203\nGeodetic CRS:  WGS 84\n   hex_id                    species          vernacular_name vertex_position\n1      32 Melithreptus validirostris Strong-billed Honeyeater               6\n2      32       Melithreptus affinis  Black-headed Honeyeater               5\n3      50 Melithreptus validirostris Strong-billed Honeyeater               6\n4      50       Melithreptus affinis  Black-headed Honeyeater               5\n5      51 Melithreptus validirostris Strong-billed Honeyeater               6\n6      51       Melithreptus affinis  Black-headed Honeyeater               5\n7      70       Melithreptus affinis  Black-headed Honeyeater               5\n8      70 Melithreptus validirostris Strong-billed Honeyeater               6\n9      88 Melithreptus validirostris Strong-billed Honeyeater               6\n10     88       Melithreptus affinis  Black-headed Honeyeater               5\n                     geometry\n1  POINT (146.7735 -44.23203)\n2  POINT (147.4663 -44.23203)\n3  POINT (145.0414 -43.23203)\n4  POINT (145.7342 -43.23203)\n5  POINT (148.5055 -43.23203)\n6  POINT (149.1983 -43.23203)\n7  POINT (147.4663 -42.23203)\n8  POINT (146.7735 -42.23203)\n9  POINT (145.0414 -41.23203)\n10 POINT (145.7342 -41.23203)\n```\n\n\n:::\n:::\n\n\n## Map\n\nLet's check how our three spatial layers—basemap, hexagons, and species points—look on a map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = ozmap_states, fill = NA) +\n  geom_sf(data = unique_hex, fill = NA) +\n  geom_sf(data = species_points, aes(colour = vernacular_name)) +\n  lims(x = c(112, 155), y = c(-46, -8)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nThis all looks correct! Now to add some final flourishes to make our map more aesthetically pleasing, as well as more accessible with a colourblind friendly palette by [Paul Tol](https://personal.sron.nl/~pault/).\n\n\n\n::: {.cell .column-page layout-align=\"center\" lightbox='{\"group\":\"final-plot\",\"description\":\"Distribution of Honeyeater species\"}'}\n\n```{.r .cell-code  code-fold=\"true\"}\nfont_add_google(\"Montserrat\")\nshowtext_auto(enable = TRUE)\n\ntol_muted <- c(\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\")\n\nggplot() +\n  geom_sf(data = ozmap_states, \n          fill = NA, colour = \"#ababab\", linewidth = 0.3) +\n  geom_sf(data = unique_hex, \n          fill = \"#efefef55\", colour = \"#777777\", linewidth = 0.5) +\n  geom_sf(data = species_points, aes(colour = vernacular_name), \n          size = 2.3) +\n  scale_colour_manual(\n    values = tol_muted,\n    guide = guide_legend(title = \"*Melithreptus* &#0020; species\",\n                         override.aes = list(size = 4))\n  ) +\n  lims(x = c(112, 155), y = c(-46, -8)) +\n  theme_void() +\n  theme(legend.title = element_markdown(family = \"Montserrat\", size = 24),\n        legend.text = element_text(family = \"Montserrat\", size = 20),\n        legend.spacing.x = unit(0, \"in\"))\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=960 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\n\n## Final Thoughts\n\nThis visualisation is a novel way to show range overlaps and distributions of multiple species at once. A key strength is the consistency of the repeatable hex unit—the fixed positions and colours of the species points make it easy to follow patterns within or between species.\n\nThis is also a very flexible method: it's easy to customise: \n\n  1. the size, shape (hexagons vs squares) and orientation of the polygons\n  2. the colours and orientations of points within the hexagons, and \n  3. the spatial scale of the base map \n\nConsider also that you do not necessarily need to use exactly seven different species/taxa—with a bit of creativity, it is possible to fit any number of points from 2-9 into a hexagon (2-7) or square symmetrically...\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](post_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n<details>\n\n<summary style=\"color: #E06E53;\">\n\nExpand for session info\n\n</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-01-25\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah       * 2.0.0   2023-12-11 [1] Github (AtlasOfLivingAustralia/galah-R@be472e8)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggtext      * 0.1.2   2022-09-16 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n patchwork   * 1.1.3   2023-08-14 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n showtext    * 0.9-6   2023-05-03 [1] CRAN (R 4.3.2)\n showtextdb  * 3.0     2020-06-04 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n sysfonts    * 0.8.8   2022-03-13 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "post_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}