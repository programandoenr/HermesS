{
  "hash": "cce1dd9aaa5285c5fde7795e3a989e44",
  "result": {
    "markdown": "---\ntitle: |\n  Download plant species data by hexagon to make a 3D hex map\ndescription: |\n  Making plots eye-catching can be useful for science communication. Here, we \n  show how to make 3D plots in R with the `rayshader` package by visualising the \n  number of species identified from ALA observations since 2020\nauthor:\n  - name: Dax Kellie\ndate: \"2022-05-23\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Eukaryota\n  - Plantae\n  - Maps\nimage: plants_3d.png\nfreeze: true\n---\n\n\n\n\n<!-- remove metadata section -->\n\n::: {.cell}\n<style type=\"text/css\">\n#title-block-header.quarto-title-block.default .quarto-title-meta {\n    display: none;\n}\n</style>\n:::\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\n[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  \n\n#### Date\n23 May 2022\n\n:::\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nGrabbing people's attention in a content-filled world can be difficult. 3D maps can be particularly eye-catching, and thanks to the [`rayshader` package](https://www.rayshader.com/) it has become relatively simple to make a beautiful 3D plot with the help of {ggplot2}.\n\nIn this post, we'll make a 3D hex map of the number of plant species identified from ALA observations since 2020. This map builds on a [previous hex map post](https://labs.ala.org.au/posts/2021-04-14_hex-maps-for-species-occurrence-data/), but this time we will use a more unique \"grid-to-data\" method to download our data, where instead of plotting hexagons over our map *after* extracting data, we'll create a grid of hexagons that map to Australia *before* extracting any data and query the ALA for data for *each* hexagon. This method is cool because it saves a lot of work wrangling your data to fit your plot later on.\n\n# Make a hexagon map\n\nFirst let's download the necessary packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# packages\nlibrary(galah)      # To download species data\nlibrary(rayshader)  # For 3d rendering\nlibrary(tidyverse)  # Data wrangling\nlibrary(here)       # Safe paths\nlibrary(sf)         # Spatial features\nlibrary(ozmaps)     # For map of oz\n```\n:::\n\n\nNow let's get a map of Australia from the [`ozmaps` package](https://github.com/mdsumner/ozmaps)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get a map and project to WGS84\noz_wgs84 <- ozmap_data(data = \"country\") |>\n  st_transform(crs = st_crs(\"WGS84\"))\n\n## check map\nggplot(oz_wgs84) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](3d-map_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nNext let's create our grid of hexagons and do some tidying to make sure the hexagons are only over the land\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create grid\noz_grid <- st_make_grid(oz_wgs84,\n                        what = \"polygons\",\n                        cellsize = 1.0,\n                        square = FALSE,\n                        flat_topped = TRUE)\n\n# subset to grid cells that are within land\nkeep_hexes <- st_intersects(oz_grid, oz_wgs84)\nkeep_hexes <- as.data.frame(keep_hexes)$row.id\noz_grid <- oz_grid[keep_hexes]\n```\n:::\n\n\nIf we plot our new `oz_grid` over our map, we can see how the hexagons fill our map of Australia\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## check\nggplot() +\n  geom_sf(data = oz_wgs84) +\n  geom_sf(data = oz_grid, fill = NA, color = \"red\")\n```\n\n::: {.cell-output-display}\n![](3d-map_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n# Download species data\n\nNow that we have our grid of hexagons, we can download data from the ALA using the [`galah` package](https://atlasoflivingaustralia.github.io/galah/index.html). Rather than downloading all data on the number of species identified since 2020 and then plotting the data as hexagons, we will make a function that sends individual queries to return the number of species identified within *each hexagon*.\n\nOur function `get_counts()` works in 3 parts:\n\n* The first part does some necessary editing of each Well Known Text (WKT) string so that they are compatible with `galah`. \n\n* The second part builds a query to download ALA data, beginning with `galah_call()`. We add the WKT for each hexagon to our query with `galah_geolocate()`, specify that we want to return only *Plantae* and *Chlorophyta* species with `galah_identify()`, and filter to only records from 2020 onwards with `galah_filter()`. We'll also add `galah_filter(profile = \"ALA\")` to use a standard ALA data quality filter (known in the ALA as as a data \"profile\"). We end our query with `atlas_counts(type = \"species\")` to return counts of species, rather than counts of records (which is the default setting). \n\n* The final part makes sure that if any hexagons have 0 species identified, they will return a 0 rather than an `NA`, which triggers an error in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_counts <- function(hexagon){\n  \n    # convert to wkt\n    wkt_string <- st_as_text(oz_grid[[hexagon]]) %>%\n      sub(\")))\", \"))\", .) %>%\n      sub(\"POLYGON \", \"POLYGON\", .)\n    \n    # get counts\n    result <- galah_call() |>\n      galah_geolocate(wkt_string) |>\n      galah_identify(\"plantae\", \"chlorophyta\") |>\n      galah_filter(decimalLongitude > 110,\n                   year >= 2020) |>\n      galah_apply_profile(ALA) |>\n      atlas_counts(type = \"species\", # get species counts\n                   limit = NULL)\n    \n    # light formatting to catch errors\n    if(is.null(result)){\n      tibble(count = NA, id = hexagon)\n    }else{\n      result$id <- hexagon\n      result\n    }\n  }\n```\n:::\n\n\nWe can use `purrr::map()` to run this function recursively for each hexagon. Then we can bind the separate lists into one data.frame with `purrr::map_dfr()`. As `oz_grid` is a spatial object containing `POLYGON`s (which R treats slightly differently to a `data.frame`), we have to use `seq_along(oz_grid)` to enable us to run the function for each line, which corresponds to each `POLYGON`.\n\n::: {.callout-warning}\nThis function will send **lots** of queries all at once to the ALA, so it is best to use restraint on how many times you run it because it can take a long time and, if run many times in a row, can make it take even longer.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# download number of species for each polygon\ncounts_list <- map(seq_along(oz_grid), get_counts)\n\n# bind lists to data frame\ncounts_df <- map_dfr(counts_list, rbind)\n```\n:::\n\n\n`counts_df` now contains a single count of species for each hexagon, indicated by a unique `id`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(counts_df, 10L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 Ã— 2\n   count    id\n   <dbl> <int>\n 1   480     1\n 2   409     2\n 3   557     3\n 4   217     4\n 5  1152     5\n 6   542     6\n 7   600     7\n 8   524     8\n 9   759     9\n10    36    10\n```\n:::\n:::\n\n\nNow let's merge our species counts in `counts_df` to our `oz_grid` hexagons so we can plot them. To do so, we'll convert `oz_grid` to a tibble called `oz_df`, add a blank `count` column, and fill that column with the species counts in `counts_df` for each hexagon by `id`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert to tibble, attach counts\noz_df <- st_as_sf(oz_grid)\noz_df$count <- NA\noz_df$count[counts_df$id] <- counts_df$count\n```\n:::\n\n\nLet's see the final result by checking the hexagons with highest species counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# See top hexagons\noz_df %>%\n  arrange(desc(count)) %>%\n  head(10L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 10 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 137.8823 ymin: -38.63203 xmax: 153.7594 ymax: -26.63203\nGeodetic CRS:  WGS 84\n   count                              x\n1   2866 POLYGON ((150.0066 -33.6320...\n2   2436 POLYGON ((144.8105 -37.6320...\n3   2360 POLYGON ((150.8726 -34.1320...\n4   2295 POLYGON ((152.6047 -28.1320...\n5   2287 POLYGON ((152.6047 -27.1320...\n6   2253 POLYGON ((150.0066 -34.6320...\n7   1974 POLYGON ((150.8726 -33.1320...\n8   1854 POLYGON ((151.7387 -27.6320...\n9   1829 POLYGON ((143.9444 -38.1320...\n10  1827 POLYGON ((137.8823 -34.6320...\n```\n:::\n:::\n\n\n\n# Plot number of species\n\nThe first step to making our 3D map is to make a 2D map with `ggplot2`. I have set the `fill` of our map to use `oz_df`'s `count` column and log transformed it to make our final scale easier to read. The `scale_fill_distiller()` function has a nice \"Greens\" palette to make our plant species data look extra planty, and I have added custom limits and labels to make sure the scale is understandable.\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nhex_map <- ggplot() +\n  geom_sf(\n    data = oz_df,\n    mapping = aes(fill = log10(count + 1)), # log10 + 1 transformed\n    alpha = 1,\n    color = NA) +\n  scale_fill_distiller(name = \"Number of species \\n(since 1 Jan, 2020)\",\n                       type = \"seq\",\n                       direction = 1,\n                       limits = c(0,4),\n                       labels = c(\"10\", \"100\", \"1,000\"),\n                       palette = \"Greens\",\n                       # edit legend to be horizontal-bottom\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"top\",\n                                                title.position = \"bottom\",\n                                                title.hjust = 0.5)\n                       ) +\n  # add map\n  geom_sf(data = oz_wgs84,\n          color = NA,\n          fill = NA)  +\n  # crop map\n  coord_sf(xlim = c(110, 155), \n           ylim = c(-45, -10)) +\n  # Adjust text and make aesthetic more minimal\n  theme(title = element_text(face = \"bold\"),\n        legend.title = element_text(size = 19),\n        legend.position = \"bottom\",\n        legend.key.width = unit(28, 'mm'),\n        legend.text = element_text(size = 16),\n        plot.background = element_rect(fill = 'white', colour = 'white'),\n        panel.background = element_rect(fill = 'white', colour = 'white'),\n        axis.title = element_blank()\n        )\n\nhex_map\n```\n\n::: {.cell-output-display}\n![](3d-map_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n# Render in 3D\n\nIt's time to get 3-Dimensional! Using `rayshader::plot_gg()`, we can render a nice 3d version of our plot^[If you get a weird error related to the `scales` package, updating to the latest version should fix it:\nhttps://github.com/tylermorganwall/rayshader/issues/181#:~:text=Update%20to%20the,install.packages(%27rayshader%27) ]\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Render 3d plot\nplot_gg(hex_map, \n        width = 9, \n        height = 8,\n        scale = 300, # adjust height of 3D transformation\n        windowsize = c(1200, 960), # adjust window of rendered plot\n        fov = 75,    # adjust size/strength of blur around outer edges\n        zoom = 0.37, \n        theta = 320, # adjust left-right rotation of view\n        phi = 33)    # adjust height of view\n```\n:::\n\n::: {.cell .column-screen layout-align=\"center\"}\n::: {.cell-output-display}\n![](../../images/dataviz/plants_hex-map.png){fig-align='center' width=600}\n:::\n:::\n\n\n\nLooks great! Finally, we can save our plot using `render_snapshot()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save\nSys.sleep(0.2)\nrender_snapshot(here(\"folder\", \"subfolder\", \"3d-map.png\"))\n```\n:::\n\n\nIn this case, a 3D map makes the areas with many and few species very noticeable, which is a useful message to communicate. \n\nHowever, in general, one should be careful about using 3D plots without first considering the main messages they want people to take away from their data, and whether a 3D figure communicates this better than a 2D alternative. People aren't as good at quickly interpreting differences in height, shape or location in 3D plots compared to 2D plots. One reason for this weakness is that most 3D plots can only be viewed from a single angle. Depending on what angle the view point of the plot is set to, the literal differences in heights or locations between shapes might change, even if their actual differences in the data they represent don't change. Looking at a 3D map from above, in the middle, or below changes how the shapes appear, and sometimes they may not accurately represent the *true* differences between things you want to compare in your plot. This quirk of 3D plots makes it easier for people to misinterpret your plot and, as a result, take away the wrong message from the data (this idea is known as the **principle of proportional ink** ([Tufte, 1983](https://www.edwardtufte.com/tufte/books_vdqi)). Carl Bergstrom has written [an excellent explanation of why this principle matters in data visualisation](https://www.callingbullshit.org/tools/tools_proportional_ink.html#:~:text=Why%20exactly%20are%203D%20bar%20charts%20harder%20to%20interpret%20than%20their%202D%20equivalents%3F%20Let%27s%20consider%20a%20relatively%20innocuous%20example%3A))\n\nEven so, 3D plots can be a beautiful way to see the number of plant species identified in the ALA since 2020. Even cooler, querying species data from the ALA for each hexagon in our map with `galah` can be an efficient way to download data and reduce data wrangling work later on! \n\n<details><summary style = \"color: #E06E53;\">Expand for session info</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2023-02-08\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package     * version date (UTC) lib source\n dplyr       * 1.1.0   2023-01-29 [1] CRAN (R 4.2.2)\n forcats     * 0.5.2   2022-08-19 [1] CRAN (R 4.2.1)\n galah       * 1.5.1   2023-01-13 [1] CRAN (R 4.2.2)\n ggplot2     * 3.3.6   2022-05-03 [1] CRAN (R 4.2.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.2.1)\n htmltools   * 0.5.4   2022-12-07 [1] CRAN (R 4.2.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.2.1)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.2.1)\n rayshader   * 0.24.10 2021-04-28 [1] CRAN (R 4.2.2)\n readr       * 2.1.3   2022-10-01 [1] CRAN (R 4.2.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.2.1)\n sf          * 1.0-8   2022-07-14 [1] CRAN (R 4.2.1)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.2.2)\n tibble      * 3.1.8   2022-07-22 [1] CRAN (R 4.2.1)\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.2.1)\n tidyverse   * 1.3.2   2022-07-18 [1] CRAN (R 4.2.1)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.2.2/library\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [
      "3d-map_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}