{
  "hash": "e49b496bf50d361615535ee5fd7b610b",
  "result": {
    "markdown": "---\ntitle: \"Sunburst plots for taxonomic data\"\ndescription: |\n  Since version 1.3.1 of {galah}, it has been possible to download taxonomic\n  data using a 'tree' format from the {data.tree} package. Here I'll demonstrate\n  some ideas for plotting these trees using circular diagrams.\nauthor: \"Martin Westgate\"\ndate: \"2022-02-17\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 3\ncategories:\n  - Trees\n  - Eukaryota\n  - Animalia\n  - Chordata\nimage: sunburst-tree.png\nfreeze: true\n---\n\n\n\n\n<!-- remove metadata section -->\n\n::: {.cell}\n<style type=\"text/css\">\n#title-block-header.quarto-title-block.default .quarto-title-meta {\n    display: none;\n}\n</style>\n:::\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\n[Martin Westgate](https://labs.ala.org.au/people/Westgate_Martin/index.html)  \n\n#### Date\nFebruary 17 2022\n\n:::\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/martin.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nTaxonomy is pretty important at the ALA. Every occurrence record in the atlas \nis linked to a unique taxonomic identifier. These identifiers are themselves\ndrawn from expertly curated taxonomic datasets. This system of classification \nis so important to our infrastructure that we have a special name for it; the \n'taxonomic backbone'. But what does it _look_ like?\n\nVisualising trees is not particularly easy for me; I didn't train in it, and the\ndata structures involved can be a bit complex. More importantly, until recently \nit was difficult to download detailed taxonomic information from the ALA. Since \nversion 1.3.1 of `galah`, however, it has been possible to download taxonomic\ntrees using the `atlas_taxonomy()` function. Let's have a go at visualising\nthese trees now. \n\n# Downloading taxonomic trees\n\nThe first step is to choose a taxonomic group to represent in tree form. I've \nchosen the chordates (Phylum Chordata) because they aren't too large a group \nand the names are fairly well-known. We can specify this within `galah` using\nthe function `galah_identify`. The second piece of information we need to \nsupply is how far 'down' the tree to travel. I've chosen the Order level here\nusing `galah_down_to(order)`; while we could have gone to the Family or even\nGenus, trying to traverse too many levels (i.e. to Genus or Species) would take \na _very_ long time. A full list of accepted ranks can be found by calling\n`show_all_ranks()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\nchordate_orders <- galah_call() |>\n  galah_identify(\"chordata\") |>\n  galah_down_to(order) |>\n  atlas_taxonomy()\n```\n:::\n\n\nThe object returned by `atlas_taxonomy` is slightly unusual; it uses the \n`data.tree` package, meaning that the dataset is literally structured like a \ntree. This is notably different from other representations of networks, such\nas you might find in `igraph`, for example. To get an idea of what the data \nlook like, we can use the inbuilt `print` method for this data type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.tree)\nprint(chordate_orders, pruneMethod = \"dist\", limit = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                            levelName\n1  Chordata                          \n2   ¦--Cephalochordata               \n3   ¦   °--Amphioxi                  \n4   ¦       °--... 1 nodes w/ 0 sub  \n5   ¦--Tunicata                      \n6   ¦   ¦--Appendicularia            \n7   ¦   ¦   °--... 1 nodes w/ 0 sub  \n8   ¦   ¦--Ascidiacea                \n9   ¦   ¦   °--... 5 nodes w/ 0 sub  \n10  ¦   °--Thaliacea                 \n11  ¦       °--... 3 nodes w/ 0 sub  \n12  °--Vertebrata                    \n13      ¦--Agnatha                   \n14      ¦   °--... 2 nodes w/ 2 sub  \n15      °--Gnathostomata             \n16          °--... 5 nodes w/ 134 sub\n```\n:::\n:::\n\n\nThis shows there are three nodes directly beneath Chordata in the taxonomic \nhierarchy, of which the largest (by number of sub-nodes) is the vertebrates\n(Vertebrata). There is a lot we could do with this tree; each node\ncontains a unique taxonomic identifer, for example, meaning that we could use\nindividual nodes to make new queries using `galah`. However, for now a useful \ntask is simply to visualise the structure of the whole tree.\n\n# Getting plot-ready data\nTaxonomic trees are complex. While all species have a Kingdom, Phylum, Order,\nClass and Family, there are many intermediate categories that are 'optional'. \nIn practice, this means that when we convert to a `data.frame` for \nplotting, there are a lot of missing values; nodes that apply to some rows but\nnot others.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_rank <- ToDataFrameTypeCol(chordate_orders, type = \"rank\")\ndf_rank[10:20,] |> tibble::as_tibble() |> print(max_footer_lines = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 10\n   rank_phylum rank_su…¹ rank_…² rank_…³ rank_…⁴ rank_…⁵ rank_…⁶ rank_…⁷ rank_…⁸\n   <chr>       <chr>     <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>  \n 1 Chordata    Tunicata  Thalia… <NA>    <NA>    <NA>    <NA>    <NA>    <NA>   \n 2 Chordata    Vertebra… <NA>    Myxini… <NA>    <NA>    <NA>    <NA>    <NA>   \n 3 Chordata    Vertebra… <NA>    Petrom… <NA>    <NA>    <NA>    <NA>    <NA>   \n 4 Chordata    Vertebra… Amphib… Gnatho… Lissam… <NA>    <NA>    <NA>    <NA>   \n 5 Chordata    Vertebra… Amphib… Gnatho… <NA>    Labyri… <NA>    <NA>    <NA>   \n 6 Chordata    Vertebra… Amphib… Gnatho… <NA>    Salien… <NA>    <NA>    <NA>   \n 7 Chordata    Vertebra… Aves    Gnatho… Neogna… <NA>    <NA>    <NA>    <NA>   \n 8 Chordata    Vertebra… Aves    Gnatho… Neogna… <NA>    <NA>    <NA>    <NA>   \n 9 Chordata    Vertebra… Aves    Gnatho… Palaeo… <NA>    Ratitae <NA>    <NA>   \n10 Chordata    Vertebra… Aves    Gnatho… Palaeo… <NA>    Ratitae <NA>    <NA>   \n11 Chordata    Vertebra… Aves    Gnatho… <NA>    <NA>    <NA>    <NA>    <NA>   \n# … with 1 more variable: rank_order <chr>, and abbreviated variable names\n#   ¹​rank_subphylum, ²​rank_class, ³​rank_informal, ⁴​rank_subclass, …\n```\n:::\n:::\n\n\nThese missing values will show up as empty sections in the resulting diagram,\nwhich isn't ideal. Instead, we can build this `data.frame` so as to place\nall nodes in order by row, with empty 'levels' being placed at the end. This \nalso avoids the problem where 'unnamed' ranks are grouped in the same column.\nTo achieve this, we simply choose a different node attribute (`level` in this \ncase) to supply to the `type` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_level <- ToDataFrameTypeCol(chordate_orders, type = \"level\")\ndf_level[10:20, ] |> tibble::as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 8\n   level_1  level_2    level_3       level_4     level_5 level_6 level_7 level_8\n   <chr>    <chr>      <chr>         <chr>       <chr>   <chr>   <chr>   <chr>  \n 1 Chordata Tunicata   Thaliacea     Salpida     <NA>    <NA>    <NA>    <NA>   \n 2 Chordata Vertebrata Agnatha       Myxini      Myxini… <NA>    <NA>    <NA>   \n 3 Chordata Vertebrata Agnatha       Petromyzon… Petrom… <NA>    <NA>    <NA>   \n 4 Chordata Vertebrata Gnathostomata Amphibia    Lissam… Anura   <NA>    <NA>   \n 5 Chordata Vertebrata Gnathostomata Amphibia    Labyri… Temnos… <NA>    <NA>   \n 6 Chordata Vertebrata Gnathostomata Amphibia    Salien… Spheno… <NA>    <NA>   \n 7 Chordata Vertebrata Gnathostomata Aves        Neogna… Accipi… <NA>    <NA>   \n 8 Chordata Vertebrata Gnathostomata Aves        Neogna… Phaeth… <NA>    <NA>   \n 9 Chordata Vertebrata Gnathostomata Aves        Palaeo… Ratitae Casuar… <NA>   \n10 Chordata Vertebrata Gnathostomata Aves        Palaeo… Ratitae Dinorn… <NA>   \n11 Chordata Vertebrata Gnathostomata Aves        Accipi… <NA>    <NA>    <NA>   \n```\n:::\n:::\n\n \nAnother problem in this dataset is the existence of duplicated taxonomic\nnames. This happens because different authorities place the same taxon in\ndifferent parts of the tree, and while the ALA tries to clean up these issues,\nsome disagreements remain. The code below assumes that each name is only\npresent once, so we have to remove duplicates to proceed. Fortunately there is \na function in package `base` that flags duplcated values as `TRUE` and unique \nvalues as `FALSE`. We can use this function to identify rows where `order` is\nnot unique.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nkeep_rows <- !duplicated(df_rank$rank_order)\ndf_rank <- filter(df_rank, keep_rows)\ndf_level <- filter(df_level, keep_rows)\n```\n:::\n\n\nThe next step is to determine how to represent this structure in a plot. At the\nmoment we can't do this, because the data are in 'wide' format. Instead, we need\nto reorder our data so that each node/taxon is represented once, and other\nplotting aesthetics can be added as additional columns. To achieve this, we \nfirst convert to 'long' format, preserving information like what row and column\neach taxonomic label was recorded in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- tibble(\n  row = rep(seq_len(nrow(df_level)), ncol(df_level)),\n  level = rep(seq_len(ncol(df_level)), each = nrow(df_level)),\n  taxon = do.call(c, df_level)) |> \n  filter(!is.na(taxon)) # remove missing values\n```\n:::\n\n\nThen, we can summarize this plot so that each row is a single taxon, recording\nsome metadata about rows and columns from the original dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_plot <- df_long |>\n  group_by(taxon) |>\n  summarize(\n    xmin = min(row) - 1, \n    xmax = max(row), \n    ymin = level[1] - 1,\n    ymax = level[1])\n     \ndf_plot\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 161 × 5\n   taxon             xmin  xmax  ymin  ymax\n   <chr>            <dbl> <int> <dbl> <int>\n 1 Acanthopterygii     61    74     6     7\n 2 Accipititrifomes    15    16     5     6\n 3 Accipitriformes     19    20     4     5\n 4 Actinopterygii      56    96     4     5\n 5 Agnatha             10    12     2     3\n 6 Albuliformes        57    58     6     7\n 7 Amphibia            12    15     3     4\n 8 Amphioxi             0     1     2     3\n 9 Amphioxiformes       0     1     3     4\n10 Anguilliformes      58    59     6     7\n# … with 151 more rows\n```\n:::\n:::\n\n\n# Drawing\nOur dataset now contains all the information we need to plot the structure of \nour taxonomic tree. As usual, we're going to plot this with `ggplot2`.\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(df_plot) +\n  geom_rect(\n    mapping = aes(\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \n      group = taxon,\n      fill = ymax),\n    color = \"white\")\n```\n\n::: {.cell-output-display}\n![](sunburst-plots_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWhile this is (probably) accurate, it's not very informative. The most obvious\nmissing element is labels; to add these, we'll need to determine which nodes \nare 'leaves', and which are 'branches'. We'll also want to restrict labelling \nto larger branches, to avoid the text looking crowded. Finally, there is no \nneed to label leaves with both a rectangle and text; so we'll remove the leaf\nrectangles from the plot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf_plot <- df_plot |> mutate(\n  x_dist = xmax - xmin,\n  is_leaf = taxon %in% df_rank$rank_order)\n\np <- ggplot() +\n  geom_rect(\n    data = filter(df_plot, !is_leaf),\n    mapping = aes(\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \n      group = taxon,\n      fill = ymax),\n    color = \"white\")\n\np +\n  # branch labels\n  geom_text(\n    data = filter(df_plot, x_dist > 5),\n    mapping = aes(\n      x = xmin + (x_dist * 0.5), \n      y = ymin + 0.5,\n      label = taxon),\n    color  = \"white\",\n    size = 3) +\n  # leaf labels\n  geom_text(\n    data = filter(df_plot, is_leaf),\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\n    angle = 90,\n    hjust = 0,\n    size = 2.5,\n    color = \"grey20\") \n```\n\n::: {.cell-output-display}\n![](sunburst-plots_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThis is better, but not ideal. A much more pleasing look is to use \n`coord_polar()` to generate a circular plot; but this leads to linear text on a \ncircular plot, which looks messy. Fortunately, the new package `geomtextpath` \nsolves this problem. All we have to do is replace `geom_text` with \n`geom_textpath`, leaving all other code the same, and add `coord_polar()` at \nthe end.\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(geomtextpath)\n\np <- p + \n  geom_textpath(\n    data = filter(df_plot, x_dist > 5),\n    mapping = aes(\n      x = xmin + (x_dist * 0.5), \n      y = ymin + 0.5,\n      label = taxon),\n    color  = \"white\",\n    size = 2.7) +\n  geom_textpath(\n    data = filter(df_plot, is_leaf),\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\n    angle = 90,\n    hjust = 0,\n    size = 2.3,\n    color = \"grey20\") +\n  coord_polar()\np\n```\n\n::: {.cell-output-display}\n![](sunburst-plots_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nFinally, we can add some finishing touches by changing the color scheme, \nhiding the background colors and legend, and resizing the y axis so all the \nlabels are visible.\n\n\n::: {.cell .column-body-outset layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(viridis)\n\np +\n  scale_fill_viridis(begin = 0, end = 0.9, direction = -1) +\n  lims(y = c(0, 9)) +\n  theme_void() + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](sunburst-plots_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=768}\n:::\n:::\n\n\nDone! This is a fun plot, but there are ways it could be expanded or improved,\nthe most obvious of which is to find ways to add supplementary information. Wouldn't it be great, for example, to add leaf-level record counts as\nmarginal barplots? Or scale the size of segments to the number of records, \nrather than the number of clades? While none of these are impossible, I'm\ngoing to leave this here for now. I hope you like the result!\n\n\n<details><summary style = \"color: #E06E53;\">Expand for session info</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2023-02-09\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version date (UTC) lib source\n data.tree    * 1.0.0   2020-08-03 [1] CRAN (R 4.2.1)\n dplyr        * 1.1.0   2023-01-29 [1] CRAN (R 4.2.2)\n galah        * 1.5.1   2023-01-13 [1] CRAN (R 4.2.2)\n geomtextpath * 0.1.1   2022-08-30 [1] CRAN (R 4.2.1)\n ggplot2      * 3.3.6   2022-05-03 [1] CRAN (R 4.2.1)\n htmltools    * 0.5.4   2022-12-07 [1] CRAN (R 4.2.2)\n sessioninfo  * 1.2.2   2021-12-06 [1] CRAN (R 4.2.1)\n viridis      * 0.6.2   2021-10-13 [1] CRAN (R 4.2.1)\n viridisLite  * 0.4.1   2022-08-22 [1] CRAN (R 4.2.1)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.2.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>",
    "supporting": [
      "sunburst-plots_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}