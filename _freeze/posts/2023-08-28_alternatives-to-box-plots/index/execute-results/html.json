{
  "hash": "9b5dd6d97feddbde881454777b17bfe6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data\"\ndescription: |\n  Box plots are a common way to summarise data in ecology and biology research, but box plots have their weaknesses. Here we'll show how easy it can be to make beeswarm and raincloud plots—two alternatives with greater data transparency—using plant trait data from {austraits}.\nauthor:\n  - name: \"Dax Kellie\"\n  - name: \"Shandiya Balasubramaniam\"\ndate: \"2023-08-28\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 2\ncategories:\n  - Eukaryota\n  - Plantae\n  - Summaries\nimage: raincloud.png\nfreeze: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n<!-- remove metadata section -->\n<style>\n  #title-block-header.quarto-title-block.default .quarto-title-meta {\n      display: none;\n  }\n</style>\n\n\n\n<!-- Author card -->\n\n:::{.author-card}\n:::{.author-card-text}\n\n#### Author\n[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/)  \n[Shandiya Balasubramaniam](https://labs.ala.org.au/about/Balasubramaniam_Shandiya/)  \n\n#### Date\n28 August 2023\n\n:::\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::{.author-card-image}\n\n::: {.cell}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/shandiya.png){width=120px style=\"clip-path: circle();\"}\n:::\n:::\n\n:::\n\n:::\n\n<!------------------------ Post starts here ------------------------>\n\nIn ecology and biology research, box plots are a wonderfully simple and efficient way to summarise data from different groups (e.g., species, populations, experimental conditions). However, this simplicity can sometimes hide the underlying structure of data, unintentionally misleading readers.\n\nLuckily, there are alternatives to displaying data with box plots, and these options have grown increasingly easy to make in R. This post shows more transparent ways to summarise data, seen through an ecological lens. \n\nIn our example, we'll compare several species of plants using a leaf trait commonly used to predict a plant's performance: leaf dry mass per area (or more simply, the size of a leaf relative to its surface area). We'll explain how to summarise this trait across a set of species using box plots, and show two ways of also displaying the distribution of the data to be more transparent. \n\n## Why not box plots? \n\nBox plots can mask differences in sample size and underlying data structure, which can make them prone to misinterpretation. One such example, shown below, is based on [Cedric Scherer's blog post on the same topic](https://www.cedricscherer.com/2021/06/06/visualizing-distributions-with-raincloud-plots-and-how-to-create-them-with-ggplot2/), which I encourage you to check out.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(ggtext)\nlibrary(gganimate)\n\n# generate sample data\nset.seed(2021)\n\ndata <- tibble(\n  group = factor(c(rep(\"Group 1\", 100), rep(\"Group 2\", 250), rep(\"Group 3\", 25))),\n  value = c(seq(0, 20, length.out = 100),\n            c(rep(0, 5), rnorm(30, 2, .1), rnorm(90, 5.4, .1), rnorm(90, 14.6, .1), rnorm(30, 18, .1), rep(20, 5)),\n            rep(seq(0, 20, length.out = 5), 5))\n  ) %>% \n  rowwise() |>\n  mutate(value = if_else(group == \"Group 2\", value + rnorm(1, 0, .4), value)) |> \n  group_by(group) |> \n  mutate(sample_size = n())\n\nanim <- ggplot(data) +\n  geom_boxplot(aes(y = value), \n               fill = \"grey92\") +\n   geom_point(aes(x = 0, y = value),\n              size = 2,\n              alpha = .3,\n              position = position_jitter(seed = 1, width = .2)) +\n  labs(title = \"N = {closest_state}\") +\n  pilot::theme_pilot() +\n  scale_x_discrete() +\n  theme(axis.title.y = element_blank(),\n        axis.title.x = element_blank(),\n        axis.text.x = element_markdown(),\n        plot.title = element_text(hjust = 0.5)) +\n  transition_states(sample_size,\n                    transition_length = 1,\n                    state_length = 2) +\n  ease_aes('cubic-in-out') +\n  enter_fly(x_loc = 0, y_loc = 15) +\n  exit_fly(x_loc = 0, y_loc = 10)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.gif){fig-align='center'}\n:::\n:::\n\n\nTo understand how to summarise data more transparently, let's see how adding data points and distributions can help improve our visualisations.\n\n\n::: {.cell}\n\n:::\n\n\n# Download data\n\nLet's start by downloading some data. We'll use the [{austraits} package](https://traitecoevo.github.io/austraits/) to get data of Australian plant traits from [AusTraits](https://austraits.org/), an open-source database of nearly 500 traits across more than 30,000 taxa from field surveys, published papers, and taxonomic books. \n\nWe can download the entire austraits dataset with the `load_austraits()` function.\n\n:::callout-note\nTo make analyses more reproducible, `load_austraits()` requires users to specify a version. You can see available versions using the `get_versions()` function.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(austraits)\n\naustraits <- load_austraits(version = \"4.1.0\", \n                            path = here::here(\"posts\", \"data\", \"austraits\"))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThere's a huge range of available plant traits, and if you are interested in seeing what else there is, you should check out their [AusTraits Plant Dictionary](https://traitecoevo.github.io/APD/) for a complete list. For a brief breakdown of trait names and the data available for each, you can use `summarise_austraits(\"trait_name\")`. Rather than showing the entire list, here's a random sample to give you an idea.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# show a sample of available traits\naustraits %>% \n  summarise_austraits(\"trait_name\") |>\n  slice_sample(n = 10) |>\n  as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 5\n   trait_name                           n_records n_dataset n_taxa percent_total\n   <chr>                                    <int>     <int>  <int>         <dbl>\n 1 leaf_work_to_shear                         192         5    137     0.000153 \n 2 leaf_lobation                             4309         5   4193     0.00344  \n 3 soil_seedbank                              522         4    515     0.000417 \n 4 leaf_cell_wall_N_per_cell_wall_dry_…        29         1     22     0.0000231\n 5 seed_shape                                2965         8   2722     0.00237  \n 6 fire_and_establishing                     1618         2   1586     0.00129  \n 7 leaflet_area                               424         5     51     0.000338 \n 8 flower_perianth_merism                     268         1    202     0.000214 \n 9 water_potential_88percent_lost_cond…        81         2     79     0.0000646\n10 wood_delta15N                              256         3     35     0.000204 \n```\n\n\n:::\n:::\n\n\n## Leaf mass per area (LMA)\n\nThe plant trait data we'll download is leaf dry mass per area (LMA), which measures how big and dense a leaf is compared to its surface area. This example from [Butrim & Royer (2020)](https://doi.org/10.1002/ajb2.1580) shows that the small, dense leaf on the top has much higher LMA than the two large, light leaves on the bottom.\n\n![](images/fossil-leaves.jpg)\n\n::: figure-caption\nLeaves from 34-33 million years ago, taken from [a post by the Botanical Society of America](https://twitter.com/Botanical_/status/1336712702111191040/photo/1)\n:::\n\nLeaf mass per area is a morphological trait that can indicate a plant's survival strategy. LMA can vary widely across species:  \n\n::: {layout-ncol=\"3\" style=\"margin-left: auto; margin-right: auto; text-align:center;\"}\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/b/a/7/2d939fe2-60fc-4530-96e3-b9a8d09e7ab3/original\" class=\"rounded clipped\"/></img><br><span style=\"text-align:center;font-weight:bold;\"> High-LMA</span>\n\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/e/0/2/0/4b70ce5c-0e4b-4892-bbf2-bae085ab020e/original\" class=\"rounded clipped\"/></img><br><span style=\"text-align:center;font-weight:bold;\"> Medium-LMA</span>\n\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/b/1/d/2/d145ba82-bc19-4b95-82e0-435ecb202d1b/original\" class=\"rounded clipped\"/></img><br><span style=\"text-align:center;font-weight:bold;\"> Low-LMA</span>\n:::\n\n::: figure-caption\nLeft: [*Dodonaea stenozyga* (Arthur Chapman CC-BY-NC-SA 4.0 (Int)](https://biocache.ala.org.au/occurrences/831aee25-3a82-4717-84f9-53d51edd225e), Middle: [*Melaleuca decora* (Greg Tasney CC-BY-SA 4.0 (Int))](https://biocache.ala.org.au/occurrences/f506528d-e804-4515-8f1b-c0d3717fde12), Right: [*Drymophila cyanocarpa* (Pete Woodall CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/d93dacd3-3d8e-489c-b7c4-bf2219d1fe65)\n:::\n\nOn one end of the spectrum, plants with small, dense leaves (**High-LMA**) acquire resources (like nutrients and energy) gradually and grow slowly, aiming to conserve what resources they have. These plants tend to have an advantage in unproductive environments, where they can efficiently store whatever limited resources are available.\n\nOn the other end of the spectrum, plants with big, light leaves (**Low-LMA**) acquire resources quickly and grow fast, aiming to out-compete others for the resources on offer. These plants tend to have an advantage in highly productive environments (where they can get lots of resources and use them quickly) ([Poorter et al. 2009](https://nph.onlinelibrary.wiley.com/doi/full/10.1111/j.1469-8137.2009.02830.x)). \n\n## Extract trait data\n\nTo download LMA trait data, we'll use `extract_trait()`. This downloads a `list` of data and metadata about authors, collection methods, locations, taxonomic information, and data structure. We'll then use `purrr::pluck()` to grab the `data.frame` we want from our list.\n\n:::callout-tip\nYou can use `lookup_trait()` to search for traits\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# lookup_trait(austraits, \"leaf_mass\")\n\n# Get trait data\nleaf_mass <- austraits |> \n  extract_trait(\"leaf_mass_per_area\") |> \n  pluck(\"traits\")\n\nleaf_mass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27,946 × 24\n   dataset_id  taxon_name      observation_id trait_name value unit  entity_type\n   <chr>       <chr>           <chr>          <chr>      <dbl> <chr> <chr>      \n 1 Ahrens_2019 Corymbia calop… 001            leaf_mass…  185. g/m2  individual \n 2 Ahrens_2019 Corymbia calop… 002            leaf_mass…  138. g/m2  individual \n 3 Ahrens_2019 Corymbia calop… 003            leaf_mass…  169. g/m2  individual \n 4 Ahrens_2019 Corymbia calop… 004            leaf_mass…  151. g/m2  individual \n 5 Ahrens_2019 Corymbia calop… 005            leaf_mass…  142. g/m2  individual \n 6 Ahrens_2019 Corymbia calop… 006            leaf_mass…  156. g/m2  individual \n 7 Ahrens_2019 Corymbia calop… 007            leaf_mass…  150. g/m2  individual \n 8 Ahrens_2019 Corymbia calop… 008            leaf_mass…  175. g/m2  individual \n 9 Ahrens_2019 Corymbia calop… 009            leaf_mass…  148. g/m2  individual \n10 Ahrens_2019 Corymbia calop… 010            leaf_mass…  135. g/m2  individual \n# ℹ 27,936 more rows\n# ℹ 17 more variables: value_type <chr>, basis_of_value <chr>,\n#   replicates <chr>, basis_of_record <chr>, life_stage <chr>,\n#   population_id <chr>, individual_id <chr>, temporal_id <chr>,\n#   source_id <chr>, location_id <chr>, entity_context_id <chr>, plot_id <chr>,\n#   treatment_id <chr>, collection_date <chr>, measurement_remarks <chr>,\n#   method_id <chr>, original_name <chr>\n```\n\n\n:::\n:::\n\n\n\n## Sample species\n\nLet's get a sample of our 6 species to summarise. To make sure that our sample species have enough data points to summarise, let's filter `leaf_mass` to only taxa with at least 10 data points. To do this, we'll count the number of data points by `taxon_name`, filter to only those with 10 data points or more, and use `pull()` to extract them. We'll save this list of names as `filtered_names`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get species with more than 10 records\nfiltered_names <- leaf_mass |>\n  group_by(taxon_name) |>\n  count() |>\n  filter(n >= 10) |>\n  pull(taxon_name)\n\nfiltered_names |> head(10L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Acacia acinacea\"       \"Acacia acuminata\"      \"Acacia anceps\"        \n [4] \"Acacia aneura\"         \"Acacia argyrophylla\"   \"Acacia aulacocarpa\"   \n [7] \"Acacia auriculiformis\" \"Acacia baileyana\"      \"Acacia bidwillii\"     \n[10] \"Acacia brachybotrya\"  \n```\n\n\n:::\n:::\n\n\nNext we'll filter our `leaf_mass` data to include only those in `filtered_names`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleaf_mass_filtered <- leaf_mass |>\n  filter(taxon_name %in% filtered_names)\n```\n:::\n\n\nThis has removed more than 3,000 taxa from our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nn_taxa <- leaf_mass |> distinct(taxon_name) |> count()\nn_taxa_filtered <- leaf_mass_filtered |> distinct(taxon_name) |> count()\n\nn_taxa - n_taxa_filtered\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     n\n1 3196\n```\n\n\n:::\n:::\n\n\n\nNext, let's get a sample of these taxa to plot. One way to get a random sample of 6 taxa is to use `filter` to return data of only 6 unique taxa names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleaf_mass_filtered |> \n  filter(taxon_name %in% sample(unique(taxon_name), 6))\n```\n:::\n\n\nHere's a random sample of taxa we prepared earlier, which we'll specify just so we can look at some extra maps after we summarise our plant trait data as well. We'll call our sample `leaf_mass_sample`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_names <- c(\"Cryptocarya rigida\", \"Pteridium esculentum\", \n                  \"Eucalyptus baxteri\", \"Melaleuca armillaris\",\n                  \"Eucalyptus wandoo\", \"Eucalyptus piperita\")\n\nleaf_mass_sample <- leaf_mass_filtered |>\n  filter(taxon_name %in% sample_names)\n```\n:::\n\n\n# Beeswarm plot\n\nThe first plot we'll learn to make is a beeswarm plot using the [{ggbeeswarm} package](https://github.com/eclarke/ggbeeswarm). Beeswarm plots are useful because they allow you to plot points next to each other that would normally overlap. These plots are especially nice because the points are plotted in a way that visualises density much like a [violin plot](https://en.wikipedia.org/wiki/Violin_plot) while still showing each individual point.\n\nLet's load {ggbeeswarm} and try plotting our plant species' trait values using `geom_quasirandom()`, which uses a sequencing algorithm to place points nicely next to each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggbeeswarm)\n\nggplot(data = leaf_mass_sample, \n       aes(x = taxon_name, \n           y = value, \n           colour = taxon_name)) +\n  ggbeeswarm::geom_quasirandom(size = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nNow let's take a few steps to clean this plot up. We'll use one of our favourite theme packages, [{pilot}](https://github.com/olihawkins/pilot), to get some nice colours and make the plot look neater. We'll also use `stringr::str_wrap()` and `reorder()` to wrap the long species names on the x-axis and order our species in ascending order. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"olihawkins/pilot\")\nlibrary(pilot) \nlibrary(stringr)\n\nggplot(data = leaf_mass_sample, \n       aes(x = taxon_name |> stringr::str_wrap(10) |> reorder(value), \n           y = value, \n           colour = taxon_name)) +\n  ggbeeswarm::geom_quasirandom(size = 2,      # size of points\n                               width = .3,    # width of points\n                               alpha = .7) +  # opacity of points\n  labs(y = \"Leaf mass per area (g/m<sup>2</sup>)\",\n       x = \"Species\") +\n  pilot::scale_color_pilot() +\n  pilot::theme_pilot(grid = \"h\",\n                     axes = \"b\") +\n  theme(legend.position = \"none\",\n        axis.title.y = ggtext::element_markdown()) # allows html in axis title\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nBecause {ggbeeswarm} places points in a semi-random but still calculated spot, the appearance is less confusing to readers than placing points randomly using other functions like `geom_jitter()`.\n\nFor extra readability, we can add a box plot along with our points to help summarise their spread, too. To help make our boxes stand out while still maintaining our colour palette, we'll use the [{colorspace} package](https://colorspace.r-forge.r-project.org/) to lighten each species' colour. \n\nThe {colorspace} package is [a toolbox designed to select clear colour palettes](https://arxiv.org/pdf/1903.06490.pdf) while accounting for visual colour deficiencies. To use {colorspace} to adjust colours after calculating each box, we'll use `after_scale()` and `lighten()` on our `fill` and `colour` arguments in `geom_boxplot()`.\n\n\n::: {.cell .column-page layout-align=\"center\" lightbox='true'}\n\n```{.r .cell-code}\nggplot(data = leaf_mass_sample, \n       aes(x = taxon_name |> stringr::str_wrap(10) |> reorder(value), \n           y = value, \n           colour = taxon_name, \n           fill = taxon_name)) +\n  geom_boxplot(\n    aes(fill = taxon_name,\n        fill = after_scale(colorspace::lighten(fill, .9)),\n        colour = taxon_name,\n        colour = after_scale(colorspace::lighten(colour, .3))),\n    size = 1,\n    outlier.shape = NA\n    ) +\n  ggbeeswarm::geom_quasirandom(size = 4, \n                               width = .25, \n                               alpha = .7) +\n  # scale_y_continuous(expand=c(0,0)) +\n  scale_y_continuous(breaks = c(0, 100, 200, 300, 400),\n                     labels = c(0, 100, 200, 300, 400),\n                     limits = c(0, 400),\n                     expand = c(0,0)) +\n  labs(y = \"Leaf mass per area (g/m<sup>2</sup>)\",\n       x = \"Species\") +\n  pilot::scale_color_pilot() +\n  pilot::scale_fill_pilot() +\n  pilot::theme_pilot(grid = \"h\",\n                     axes = \"b\") + \n  theme(legend.position = \"none\",\n        axis.title.y = ggtext::element_markdown(),\n        axis.text.x = element_text(face = \"italic\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=864 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\n\n# Raincloud plots\n\nIn 2019, [raincloud plots](https://wellcomeopenresearch.org/articles/4-63) were proposed as one way to visualise data with \"maximal statistical information while preserving the desired ‘inference at a glance’ nature of barplots and other similar visualization devices.\" By displaying points, densities and summary stats like median, mean and confidence intervals, raincloud plots are robust, informative, and (dare I say it) stunning.\n\nLet's plot the same data of our 6 species above as a raincloud plot. We'll load the [{ggdist} package](https://mjskay.github.io/ggdist/index.html) and the [{gghalves} package](https://github.com/erocoar/gghalves) to allow us to plot different parts of our raincloud plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdist)\nlibrary(gghalves)\n```\n:::\n\n\nTo begin, let's plot the distribution on one half of our raincloud plot using `stat_halfeye()`, and the points that make up that distribution on the other half of our plot with `geom_half_point()`. We'll also flip our plot on its side using `coord_flip()` to give our plot and labels more space (and to eventually help make our raincloud effect)^[Are plots with bars or boxes any easier to read when oriented up and down (ie. vertically) than side-to-side (ie. horizontally)? You might not have an immediate answer, and so it's slightly strange (when you think about it) how deep-set the trend of vertical barplots and box plots is in science. Flipping your plot can make longer names easier to read, make group differences easier to spot when stacked in order, and give space to other elements in your plot!]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = leaf_mass_sample, \n       aes(x = taxon_name |> stringr::str_wrap(10) |> reorder(value), \n           y = value, \n           colour = taxon_name, \n           fill = taxon_name)) +\n  ggdist::stat_halfeye(adjust = .4,           # smoothness of distribution\n                       width = .87,           # height of distribution\n                       colour = NA) +\n  gghalves::geom_half_point(side = \"l\",       # choose right or left side\n                            range_scale = .3, # spread of points\n                            alpha = .6,\n                            size = 2.2) +\n  coord_flip() +\n  labs(x = \"Species\",\n       y = \"Leaf mass to area\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nNow we can add our box plot, using our `after_stat()` colorspace trick within `geom_boxplot()`, this time to darken the lines of each box. We'll also use {pilot} to add some nice colours and styling to our plot.\n\nAnd just like that we can make it rain!^[Fun fact: \"How to make it rain\" is an actual subheading in the paper]\n\n\n::: {.cell .column-page layout-align=\"center\" lightbox='true'}\n\n```{.r .cell-code}\nggplot(data = leaf_mass_sample, \n       aes(x = taxon_name |> stringr::str_wrap(10) |> reorder(value), \n           y = value, \n           colour = taxon_name, \n           fill = taxon_name)) +\n  ggdist::stat_halfeye(adjust = .4,\n                       width = .87,\n                       colour = NA) +\n  gghalves::geom_half_point(side = \"l\",\n                            range_scale = .3,\n                            alpha = .6,\n                            size = 2.2) +\n  geom_boxplot(\n    aes(colour = taxon_name,\n        colour = after_scale(colorspace::darken(colour, .7))),\n    width = .12,        # adjust box width\n    fill = NA,\n    size = 1.1,         # size of box line\n    outlier.shape = NA  # remove outlier points\n    ) +\n  coord_flip() +\n  labs(x = \"Species\",\n       y = \"Leaf mass per area (g/m<sup>2</sup>)\") +\n  scale_y_continuous(breaks = c(0, 100, 200, 300, 400),\n                     labels = c(0, 100, 200, 300, 400),\n                     limits = c(0, 400),\n                     expand = c(0,0)) +\n  pilot::scale_color_pilot() +\n  pilot::scale_fill_pilot() +\n  pilot::theme_pilot(grid = \"\",\n                     axes = \"b\") + \n  theme(legend.position = \"none\",\n        axis.title.x = ggtext::element_markdown(),\n        axis.text.y = element_text(face = \"italic\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=864 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\n\n# Bonus: Plant distribution\n\nLet's briefly revisit leaf dry mass per area (LMA) before ending. The relationship between LMA and plant functioning means we can *infer* the type of ecosystem a plant lives in based on its LMA. So let's see where the 6 plant species that we summarised above live! \n\nRemember, **low-LMA** species like *Cryptocarya rigida* have big, light leaves that thrive in wetter ecosystems with lots of nutrients. Alternatively, **high-LMA** species like *Eucalyptus wandoo* have small, dense leaves that thrive in drier ecosystems with little nutrients. We've added the median LMA of each species to help compare.\n\nIs this where you expected these plants to be found?\n\n\n::: {.cell layout-align=\"center\" lightbox='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(galah)\nlibrary(sf)\nlibrary(ozmaps)\n\n# Download data\ngalah_config(email = \"dax.kellie@csiro.au\", verbose = FALSE)\n\nplants <- galah_call() |>\n  galah_identify(sample_names) |>\n  galah_apply_profile(ALA) |>\n  atlas_occurrences()\n\n# Recategorise subspecies into species categories\nplants <- plants |>\n  drop_na(decimalLatitude, decimalLatitude) |>\n  mutate(names = case_when(\n    str_detect(scientificName, \"Eucalyptus wandoo\") ~ \"Eucalyptus wandoo\",\n    str_detect(scientificName, \"Pentameris airoides\") ~ \"Pentameris airoides\",\n    str_detect(scientificName, \"Melaleuca armillaris\") ~ \"Melaleuca armillaris\",\n    str_detect(scientificName, \"Pteridium esculentum\") ~ \"Pteridium esculentum\",\n    .default = scientificName)\n    )\n\n# Join median LMAs for each species to `plants` tibble\nplants_lma <- leaf_mass_sample |>\n  group_by(taxon_name) |>\n  summarise(median_lma = median(value) |> round(1)) |>\n  right_join(plants, by = join_by(taxon_name == scientificName)) |>\n  rename(scientificName = taxon_name) |>\n  drop_na(median_lma) # remove NAs for unmatched subspecies\n\n# Australia map\naus <- ozmaps::ozmap_country |>\n  st_transform(crs = st_crs(4326))\n\n# Map points\nggplot() +\n  geom_sf(data = aus,\n          colour = \"grey60\",\n          fill = NA) +\n  geom_point(data = plants_lma,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude,\n                 colour = names),\n             shape = 16,\n             alpha = 0.4) +\n  pilot::scale_color_pilot() +\n  pilot::theme_pilot() +\n  coord_sf(xlim = c(110, 155), \n           ylim = c(-45, -10)) +\n  facet_wrap( ~ names, ncol = 3) + \n  geom_text(data = plants_lma,\n            mapping = aes(x = 116, y = -11, \n                          label = glue(\"LMA = {median_lma}\"), \n                          group = names),\n            colour = \"grey40\",\n            family = theme_get()$text$family, # use theme settings\n            size = 3.5,\n            lineheight = 0.92) +\n  theme(legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        panel.border = element_rect(linewidth = 1, \n                                    colour = \"grey90\", \n                                    fill = NA)\n        )\n```\n\n::: {.cell-output-display}\n![Figures display each species' median LMA value.](index_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n\n# Final thoughts\n\nBox plots are great because they are simple and can be interpreted quickly. These days, there are alternative options that are still simple but more robust and transparent. We hope you feel inspired to try out a beeswarm or raincloud plot yourself! (Maybe you even learned a little something about plants and their leaves as well)\n\nThere might be other statistics you might like to use to summarise your data. It's possible to add means and confidence intervals to raincloud plots, too, though methods differ slightly to other visualisation tools[^Tip]. Experiment with what works best with your data.\n\nFor other great resources on alternatives to box and bar plots in R, check out [this article by Cedric Scherer](https://z3tt.github.io/beyond-bar-and-box-plots/) which we found really helpful.\n\n[^Tip]: If you would like to add mean and confidence intervals (rather than median and quantile intervals) to your raincloud plot, you can use `stat_pointinterval()` to do this. However, {ggdist} calculates confidence intervals using a Bayesian method to find point estimates and Highest Density Intervals (HDI). This method returns different estimates to Frequentist confidence intervals, so it's worth looking up the difference before using HDIs. If you are plotting estimates after running a model, [the suggested way by the creator of {ggdist}](https://mjskay.github.io/ggdist/articles/freq-uncertainty-vis.html) is to pass this information using `dist_student_t()` and model parameters from `broom::tidy()` output. This [stack overflow thread](https://stackoverflow.com/questions/72987914/what-does-ggdists-stat-interval-levels-calculate-i-thought-it-was-confidence) we found helpful for getting started.\n\n\n\n<details><summary style = \"color: #E06E53;\">Expand for session info</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-03-07\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n austraits   * 2.1.2   2023-07-11 [1] Github (traitecoevo/austraits@53b637c)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n gganimate   * 1.0.8   2022-09-08 [1] CRAN (R 4.3.2)\n ggbeeswarm  * 0.7.2   2023-04-29 [1] CRAN (R 4.3.2)\n ggdist      * 3.3.1   2023-11-27 [1] CRAN (R 4.3.2)\n gghalves    * 0.1.4   2022-11-20 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggtext      * 0.1.2   2022-09-16 [1] CRAN (R 4.3.2)\n glue        * 1.6.2   2022-02-24 [1] CRAN (R 4.3.2)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n pilot       * 4.0.0   2022-07-13 [1] Github (olihawkins/pilot@f08cc16)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n RefManageR  * 1.4.0   2022-09-30 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}